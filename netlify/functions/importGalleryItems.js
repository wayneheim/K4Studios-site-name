// netlify/functions/importGalleryItems.js
const fs = require("fs/promises");
const path = require("path");

/* guards & path helpers (same as your other fns) */
const ALLOWED_ROOTS = ["src/data/Galleries", "src/pages/Other"];
const toPosix = (p = "") => String(p).replace(/\\/g, "/");
const hasTraversal = (p = "") => p.split(/[\\/]+/).some(seg => seg === "..");
function resolveDatasetAbsolute(datasetPath) {
  const rel = toPosix(String(datasetPath || "").replace(/^\//, ""));
  if (!rel || hasTraversal(rel) || !rel.endsWith(".mjs")) throw new Error("Invalid datasetPath");
  const ok = ALLOWED_ROOTS.some(root => rel.startsWith(toPosix(root) + "/"));
  if (!ok) throw new Error("Dataset must be under src/data/Galleries or src/pages/Other");
  return path.join(process.cwd(), rel);
}

/* helpers */
const isGhost = (d) => d && d.id === "i-k4studios";
const isReal  = (d) => d && !isGhost(d);

function normalizeItem(raw) {
  const notes = raw.notes ?? raw.collectorNotes;
  const keywords = Array.isArray(raw.keywords)
    ? raw.keywords
    : Array.isArray(raw.tags)
    ? raw.tags
    : undefined;

  const out = {};
  if (raw.id != null) out.id = raw.id;
  if (raw.title != null) out.title = raw.title;
  if (raw.description != null) out.description = raw.description;
  if (raw.alt != null) out.alt = raw.alt;
  if (raw.src != null || raw.url != null) out.src = raw.src || raw.url;
  if (raw.buyLink != null) out.buyLink = raw.buyLink;
  if (keywords != null) out.keywords = keywords;
  if (raw.story != null) out.story = raw.story;
  if (notes != null) out.notes = notes;
  if (typeof raw.rating === "number") out.rating = raw.rating;
  if (Array.isArray(raw.galleries)) out.galleries = raw.galleries;
  if (raw.visibility != null) out.visibility = raw.visibility;
  if (typeof raw.sortOrder === "number") out.sortOrder = raw.sortOrder;
  return out;
}

function buildMjsJson(galleryData, exportName = "galleryData") {
  const json = JSON.stringify(galleryData.map(normalizeItem), null, 2);
  return `// Auto-generated by GalleryImporter â€“ review & commit
export const ${exportName} = ${json};
`;
}

/* parse helper ONLY used as a fallback if client didn't send items */
function extractArrayFromMjs(code) {
  const m = code.match(/export\s+const\s+galleryData\s*=\s*(\[[\s\S]*\]);?/);
  if (!m) return null;

  // Provide a tiny String.raw shim so template literals don't explode.
  // eslint-disable-next-line no-new-func
  const fn = new Function(`
    const String = { raw: (...args) => (Array.isArray(args[0]) ? args[0][0] : String(args[0])) };
    const x = ${m[1]};
    return x;
  `);
  try { return fn(); } catch { return null; }
}

exports.handler = async (event) => {
  if (event.httpMethod !== "POST") return { statusCode: 405, body: "Method Not Allowed" };

  try {
    const { toDatasetPath, fromDatasetPath, selectedIds, selectedItems } = JSON.parse(event.body || "{}");
    if (!toDatasetPath || !fromDatasetPath) {
      return { statusCode: 400, body: "Missing toDatasetPath or fromDatasetPath" };
    }

    // resolve both files
    let toAbs, fromAbs;
    try { toAbs = resolveDatasetAbsolute(toDatasetPath); fromAbs = resolveDatasetAbsolute(fromDatasetPath); }
    catch (e) { return { statusCode: 400, body: e.message }; }

    try { await fs.access(toAbs); }   catch { return { statusCode: 404, body: `Target not found: ${toDatasetPath}` }; }
    try { await fs.access(fromAbs); } catch { return { statusCode: 404, body: `Source not found: ${fromDatasetPath}` }; }

    // Read target
    const toCode = await fs.readFile(toAbs, "utf8");
    const toArr  = extractArrayFromMjs(toCode);
    if (!Array.isArray(toArr)) return { statusCode: 400, body: "Failed to parse target galleryData" };
    const toGhosts = toArr.filter(isGhost);
    const toVis    = toArr.filter(isReal);

    // Get source items either from client (preferred) or by parsing the file
    let sourceVis = Array.isArray(selectedItems) && selectedItems.length
      ? selectedItems.filter(isReal)
      : null;

    if (!sourceVis) {
      const fromCode = await fs.readFile(fromAbs, "utf8");
      const fromArr  = extractArrayFromMjs(fromCode);
      if (!Array.isArray(fromArr)) return { statusCode: 400, body: "Failed to parse source galleryData" };
      const all = fromArr.filter(isReal);
      const want = Array.isArray(selectedIds) && selectedIds.length ? new Set(selectedIds) : null;
      sourceVis = want ? all.filter(x => want.has(x.id)) : all;
    }

    // Append, skipping id collisions; resequence sortOrder
    const existingIds = new Set(toVis.map(x => x.id));
    const picked = [];
    const skippedIds = [];
    let next = toVis.length;

    for (const it of sourceVis) {
      if (!it?.id) continue;
      if (existingIds.has(it.id)) { skippedIds.push(it.id); continue; }
      picked.push({ ...it, sortOrder: next++ });
    }

    const finalArr = toGhosts.concat(toVis, picked);
    const outText  = buildMjsJson(finalArr, "galleryData");
    await fs.writeFile(toAbs, outText, "utf8");

    return {
      statusCode: 200,
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        ok: true,
        to: toDatasetPath,
        from: fromDatasetPath,
        imported: picked.length,
        skippedIds,
        total: finalArr.length,
      }),
    };
  } catch (err) {
    console.error(err);
    return { statusCode: 500, body: err?.message || "Server error" };
  }
};
