// src/components/GalleryOrderer.jsx
import { useEffect, useMemo, useRef, useState } from "react";

/* ========= helpers ========= */
function downloadText(text, filename) {
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function pickImage(d = {}) {
  return (
    d.url ||
    d.src ||
    d.imageUrl ||
    d.cover ||
    d.hero?.src ||
    d.preview?.src ||
    d.images?.[0]?.url ||
    d.images?.[0]?.src ||
    ""
  );
}

function isGhost(d) { return d && d.id === "i-k4studios"; }
function isRealItem(d) { return d && !isGhost(d); }

/** Normalize item -> your JSON-style schema (quoted keys/values) */
function normalizeItem(raw) {
  const notes = raw.notes ?? raw.collectorNotes;
  const keywords = Array.isArray(raw.keywords)
    ? raw.keywords
    : Array.isArray(raw.tags)
    ? raw.tags
    : undefined;

  const out = {};
  if (raw.id != null) out.id = raw.id;
  if (raw.title != null) out.title = raw.title;
  if (raw.description != null) out.description = raw.description;
  if (raw.alt != null) out.alt = raw.alt;
  if (raw.src != null || raw.url != null) out.src = raw.src || raw.url;
  if (raw.buyLink != null) out.buyLink = raw.buyLink;
  if (keywords != null) out.keywords = keywords;
  if (raw.story != null) out.story = raw.story;
  if (notes != null) out.notes = notes;
  if (typeof raw.rating === "number") out.rating = raw.rating;
  if (Array.isArray(raw.galleries)) out.galleries = raw.galleries;
  if (raw.visibility != null) out.visibility = raw.visibility;
  if (typeof raw.sortOrder === "number") out.sortOrder = raw.sortOrder;
  return out;
}

function buildMjsJson(galleryData, exportName = "galleryData") {
  const json = JSON.stringify(galleryData.map(normalizeItem), null, 2);
  return `// Auto-generated by GalleryOrderer – review & commit
export const ${exportName} = ${json};
`;
}

/** Simple array reordering */
function arrayMove(arr, from, to) {
  if (from === to) return arr;
  const copy = arr.slice();
  const item = copy.splice(from, 1)[0];
  copy.splice(to, 0, item);
  return copy;
}

/** Read ?dataset=... from URL (supports hash routers, too) */
function getDatasetFromUrl() {
  try {
    const search =
      window.location.search ||
      (window.location.hash.includes("?")
        ? window.location.hash.split("?")[1]
        : "");
    const params = new URLSearchParams(search);
    const raw = params.get("dataset");
    if (!raw) return "";
    const path = raw.startsWith("/") ? raw : `/${raw}`;
    return path.startsWith("/src/") ? path : `/src/${path}`;
  } catch {
    return "";
  }
}

/* ========= Component (Grid-only, server save) ========= */
export default function GalleryOrderer({ datasetPath = "" }) {
  // discover all datasets
  const modules = useMemo(
    () =>
      import.meta.glob("/src/data/Galleries/**/*.mjs", {
        eager: false,
        import: "galleryData",
      }),
    []
  );

  const options = useMemo(() => {
    const makeLabel = (p) =>
      p
        .replace("/src/data/Galleries/", "")
        .replace(/\.mjs$/, "")
        .replace(/-/g, " ")
        .replace(/\b\w/g, (m) => m.toUpperCase());
    return Object.keys(modules)
      .sort()
      .map((path) => ({ path, label: makeLabel(path) }));
  }, [modules]);

  const [selectedPath, setSelectedPath] = useState("");
  const [backupData, setBackupData] = useState(null);   // full array as loaded (incl ghost)
  const [items, setItems] = useState([]);               // working order (ghost excluded)
  const [backupMade, setBackupMade] = useState(false);
  const [dirty, setDirty] = useState(false);
  const [lastAction, setLastAction] = useState(null);

  // UI state
  const [thumb, setThumb] = useState(180);
  const [showTitles, setShowTitles] = useState(false);
  const [filter, setFilter] = useState("");

  // undo stack for last move
  const lastMoveRef = useRef(null); // {from,to,snapshot}

  // Choose dataset: prefer prop → URL → first option
  useEffect(() => {
    if (!options.length) return;
    const fromProp = datasetPath
      ? (datasetPath.startsWith("/") ? datasetPath : `/${datasetPath}`)
      : "";
    const candidate = fromProp || getDatasetFromUrl() || options[0]?.path || "";
    setSelectedPath(options.some(o => o.path === candidate) ? candidate : (options[0]?.path || ""));
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [options.length, datasetPath]);

  // load dataset
  useEffect(() => {
    let cancelled = false;
    async function load() {
      if (!selectedPath) return;
      const mod = await modules[selectedPath]();
      const arr = Array.isArray(mod) ? mod : [];
      if (cancelled) return;

      setBackupData(arr);
      const vis = arr.filter(isRealItem);
      setItems(vis);
      setBackupMade(false);
      setDirty(false);
      setFilter("");
      setShowTitles(false);
      lastMoveRef.current = null;
      setLastAction(null);
    }
    load();
    return () => { cancelled = true; };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedPath]);

  function note(msg) {
    setLastAction(`${msg} — ${new Date().toLocaleTimeString()}`);
    window.setTimeout(() => setLastAction(null), 6000);
  }

  function ensureBackup() {
    if (!backupData) return;
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    downloadText(JSON.stringify(backupData, null, 2), `ORDER-BACKUP-${ts}.json`);
    downloadText(buildMjsJson(backupData, "galleryData"), `ORDER-BACKUP-${ts}.mjs`);
    setBackupMade(true);
    note("Backup created, ordering unlocked");
  }

  // filter
  const filtered = useMemo(() => {
    const base = items;
    const q = filter.trim().toLowerCase();
    if (!q) return base;
    return base.filter((d) =>
      [d.id, d.title, d.alt, d.description, d.story]
        .filter(Boolean)
        .some((v) => String(v).toLowerCase().includes(q))
    );
  }, [items, filter]);

  // indices map (id -> index in items)
  const idxById = useMemo(() => {
    const m = new Map();
    items.forEach((it, i) => m.set(it.id, i));
    return m;
  }, [items]);

  // drag handlers
  const dragFromIndex = useRef(null);

  function onDragStart(e, id) {
    if (!backupMade) { e.preventDefault(); return; }
    const idx = idxById.get(id);
    dragFromIndex.current = idx;
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", id);
  }
  function onDragOver(e) { if (dragFromIndex.current == null) return; e.preventDefault(); }
  function onDrop(e, overId) {
    e.preventDefault();
    const from = dragFromIndex.current;
    const to = idxById.get(overId);
    dragFromIndex.current = null;
    if (from == null || to == null || from === to) return;
    lastMoveRef.current = { from, to, snapshot: items.slice() };
    setItems((arr) => arrayMove(arr, from, to));
    setDirty(true);
    note(`Moved #${from + 1} → #${to + 1}`);
  }

  function resetOrder() {
    if (!backupData) return;
    setItems(backupData.filter(isRealItem));
    setDirty(false);
    lastMoveRef.current = null;
    note("Order reset to loaded");
  }
  function undoLastMove() {
    const u = lastMoveRef.current;
    if (!u) return;
    setItems(u.snapshot);
    setDirty(true);
    lastMoveRef.current = null;
    note("Undid last move");
  }

  // Build final array (ghost first, then reordered items), resequence sortOrder
  function buildFinalArray() {
    if (!backupData) return [];
    const ghosts = backupData.filter(isGhost);
    const vis = items.slice();
    vis.forEach((it, i) => { it.sortOrder = i; });
    return ghosts.concat(vis);
  }

  // Save to server (Netlify function) – same pattern as your editor
  async function saveOrderHere() {
    if (!backupMade) { alert("Please create a backup first."); return; }
    if (!selectedPath) return;

    const datasetPathClean = selectedPath.replace(/^\//, ""); // strip leading slash
    const orderIds = items.map((it) => it.id);

    try {
      const res = await fetch("/.netlify/functions/updateGalleryOrder", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          datasetPath: datasetPathClean, // e.g. src/data/.../Color.mjs
          orderIds,                      // the new visual order
          sourceArray: backupData,       // full original array including ghost (server will normalize)
          // Or send fullArray: buildFinalArray()
        }),
      });
      if (!res.ok) throw new Error(await res.text());
      note("Saved order in-place");
      setDirty(false);
    } catch (err) {
      alert("Server save failed. Falling back to download.\n\n" + err.message);
      const filename = datasetPathClean.split("/").pop() || "gallery.mjs";
      const text = buildMjsJson(buildFinalArray(), "galleryData");
      downloadText(text, filename);
      note(`Downloaded → ${filename}`);
      setDirty(false);
    }
  }

  // Optional manual download
  function saveAsDownload() {
    if (!selectedPath) return;
    const datasetPathClean = selectedPath.replace(/^\//, "");
    const filename = datasetPathClean.split("/").pop() || "gallery.mjs";
    const text = buildMjsJson(buildFinalArray(), "galleryData");
    downloadText(text, filename);
    note(`Downloaded → ${filename}`);
    setDirty(false);
  }

  const total = items.length;

  return (
    <div className="p-6 max-w-7xl mx-auto text-sm">
      <h1 className="text-2xl font-semibold mb-3">Gallery Orderer</h1>

      {/* dataset + backup gate */}
      <div className="flex flex-wrap items-center gap-2 mb-3">
        <select
          className="border rounded-md px-2 py-1 min-w-[22rem]"
          value={selectedPath}
          onChange={(e) => setSelectedPath(e.target.value)}
        >
          {options.map((o) => (
            <option key={o.path} value={o.path}>
              {o.label}
            </option>
          ))}
        </select>

        {!backupMade ? (
          <button onClick={ensureBackup} className="px-3 py-1 rounded-md border bg-white">
            1) Make Data Backup
          </button>
        ) : (
          <span className="text-green-700">✅ Backup created — ordering unlocked</span>
        )}

        <div className="ml-auto flex items-center gap-2">
          <input
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
            placeholder="Search id/title/text…"
            className="w-72 border rounded-md px-2 py-1"
          />
          <label className="flex items-center gap-1 px-2 py-1 border rounded-md">
            <input
              type="checkbox"
              checked={showTitles}
              onChange={() => setShowTitles((v) => !v)}
            />
            Titles
          </label>
          <div className="flex items-center gap-2 border rounded-md px-2 py-1">
            <span className="opacity-70">Thumb</span>
            <input
              type="range"
              min={90}
              max={320}
              value={thumb}
              onChange={(e) => setThumb(Number(e.target.value))}
            />
          </div>
        </div>
      </div>

      {/* actions */}
      <div className="mb-3 flex flex-wrap items-center gap-2">
        {dirty && <span className="text-red-600 font-medium">Unsaved order</span>}

        <button onClick={saveOrderHere} className="px-3 py-1 rounded-md border">
          Save Here (server)
        </button>
        <button onClick={saveAsDownload} className="px-3 py-1 rounded-md border">
          Download .mjs
        </button>
        <button onClick={resetOrder} className="px-3 py-1 rounded-md border">
          Reset To Loaded
        </button>
        <button onClick={undoLastMove} className="px-3 py-1 rounded-md border">
          Undo Last Move
        </button>

        <span className="ml-auto opacity-70">{filtered.length}/{total}</span>

        {lastAction && (
          <span className="ml-2 text-xs bg-green-50 border border-green-200 text-green-800 px-2 py-1 rounded-md">
            {lastAction}
          </span>
        )}
      </div>

      {/* grid DnD — inline styles force grid even if Tailwind fails to load */}
      <div
        className={`${!backupMade ? "pointer-events-none opacity-60" : ""}`}
        style={{
          display: "grid", // force grid layout
          gap: "0.75rem",  // ~ gap-3
          gridTemplateColumns: `repeat(auto-fill, minmax(${thumb}px, 1fr))`,
        }}
      >
        {filtered.map((it) => {
          const img = pickImage(it);
          const i = items.findIndex((x) => x.id === it.id);
          return (
            <div
              key={it.id}
              draggable
              onDragStart={(e) => onDragStart(e, it.id)}
              onDragOver={onDragOver}
              onDrop={(e) => onDrop(e, it.id)}
              className="border rounded-md bg-white overflow-hidden shadow-sm"
              title={`#${i + 1} – ${it.id}`}
            >
              {img ? (
                <img
                  src={img}
                  alt=""
                  className="block w-full"
                  style={{ height: thumb, objectFit: "cover" }}
                />
              ) : (
                <div className="w-full grid place-items-center" style={{ height: thumb }}>
                  No image
                </div>
              )}
              <div className="flex items-center justify-between px-2 py-1 text-xs border-t bg-gray-50">
                <span className="font-medium">#{i + 1}</span>
                {showTitles ? (
                  <span className="truncate ml-2" title={it.title || ""}>
                    {it.title || it.id}
                  </span>
                ) : (
                  <span className="opacity-60 truncate ml-2">{it.id}</span>
                )}
              </div>
            </div>
          );
        })}
      </div>

      <div className="mt-4 text-xs opacity-70">
        Drag to reorder. Click <strong>Save Here (server)</strong> to overwrite the dataset file via Netlify
        function (same pattern as your editor). If the server save fails, use <strong>Download .mjs</strong> as a fallback.
      </div>
    </div>
  );
}
