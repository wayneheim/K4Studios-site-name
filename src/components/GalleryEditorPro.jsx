import { useEffect, useMemo, useState } from "react";

/* ---------- helpers ---------- */
function escapeForTemplate(str = "") {
  let s = String(str).replace(/\r\n/g, "\n");
  s = s.replace(/`/g, "\\`");
  s = s.replace(/\$\{/g, "\\${");
  return s;
}

function buildMjs(galleryData, exportName = "galleryData") {
  const body = galleryData
    .map((it) => {
      const out = [];
      const pushStr = (k, v) => out.push(`    ${k}: String.raw\`${escapeForTemplate(v)}\`,`);
      const pushVal = (k, v) => out.push(`    ${k}: ${v},`);

      if (it.id != null) pushStr("id", it.id);
      if (it.title != null) pushStr("title", it.title);
      if (it.alt != null) pushStr("alt", it.alt);
      if (it.description != null) pushStr("description", it.description);
      if (it.story != null) pushStr("story", it.story);
      if (it.collectorNotes != null) pushStr("collectorNotes", it.collectorNotes);
      if (it.notes != null) pushStr("notes", it.notes); // some files use 'notes'
      if (it.url != null) pushStr("url", it.url);
      if (it.src != null) pushStr("src", it.src);
      if (it.section != null) pushStr("section", it.section);
      if (typeof it.rating === "number") pushVal("rating", it.rating);
      if (Array.isArray(it.tags)) out.push(`    tags: ${JSON.stringify(it.tags)},`);
      if (Array.isArray(it.keywords)) out.push(`    keywords: ${JSON.stringify(it.keywords)},`);
      if (Array.isArray(it.galleries)) out.push(`    galleries: ${JSON.stringify(it.galleries)},`);
      if (it.visibility != null) pushStr("visibility", it.visibility);
      if (typeof it.sortOrder === "number") pushVal("sortOrder", it.sortOrder);
      if (it.buyLink != null) pushStr("buyLink", it.buyLink);
      return `  {\n${out.join("\n")}\n  }`;
    })
    .join(",\n");

  return `// Auto-generated by GalleryEditorPro – review & commit
export const ${exportName} = [
${body}
];
`;
}

function downloadText(text, filename) {
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// choose an image URL from common fields
function pickImage(d = {}) {
  return (
    d.url ||
    d.src ||
    d.imageUrl ||
    d.cover ||
    d.hero?.src ||
    d.preview?.src ||
    d.images?.[0]?.url ||
    d.images?.[0]?.src ||
    ""
  );
}

// UI should hide the ghost, but we preserve it in file saves
function isRealItem(d) {
  return d && d.id !== "i-k4studios";
}

/* ---------- component ---------- */
export default function GalleryEditorPro() {
  // Discover all .mjs gallery datasets (expects `export const galleryData = [...]`)
  const modules = useMemo(
    () =>
      import.meta.glob("/src/data/Galleries/**/*.mjs", {
        eager: false,
        import: "galleryData",
      }),
    []
  );

  const options = useMemo(() => {
    const makeLabel = (p) =>
      p
        .replace("/src/data/Galleries/", "")
        .replace(/\.mjs$/, "")
        .replace(/-/g, " ")
        .replace(/\b\w/g, (m) => m.toUpperCase());
    return Object.keys(modules)
      .sort()
      .map((path) => ({ path, label: makeLabel(path) }));
  }, [modules]);

  const [selectedPath, setSelectedPath] = useState(options[0]?.path || "");
  const [data, setData] = useState([]);         // UI list (ghost removed)
  const [backupData, setBackupData] = useState(null); // FULL array as loaded (ghost preserved)
  const [idx, setIdx] = useState(0);
  const [filter, setFilter] = useState("");
  const [dirty, setDirty] = useState(false);
  const [backupMade, setBackupMade] = useState(false);

  const [lastAction, setLastAction] = useState(null);
  useEffect(() => {
    if (!lastAction) return;
    const t = setTimeout(() => setLastAction(null), 6000);
    return () => clearTimeout(t);
  }, [lastAction]);

  const keyLS = (suffix) => `k4-editor:${selectedPath}:${suffix}`;

  // Load dataset when changed
  useEffect(() => {
    let cancelled = false;
    async function load() {
      if (!selectedPath) return;
      const mod = await modules[selectedPath](); // dynamic import -> array
      const allArr = Array.isArray(mod) ? mod : []; // keep EVERYTHING for saving
      const arr = allArr.filter(isRealItem);       // UI only

      if (cancelled) return;

      // optional draft restore
      const draftRaw = localStorage.getItem(keyLS("draft"));
      const draft = draftRaw ? JSON.parse(draftRaw) : null;

      setData(draft && Array.isArray(draft) && draft.length ? draft.filter(isRealItem) : arr);
      setBackupData(allArr); // full original (incl. ghost)
      setIdx(0);
      setFilter("");
      setDirty(false);
      setBackupMade(false); // require backup step per dataset
      setLastAction(null);
    }
    load();
    return () => {
      cancelled = true;
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedPath]);

  // Autosave draft
  useEffect(() => {
    if (!selectedPath || !data) return;
    try {
      localStorage.setItem(keyLS("draft"), JSON.stringify(data));
    } catch {}
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data]);

  const filtered = useMemo(() => {
    const base = data;
    if (!filter.trim()) return base;
    const q = filter.toLowerCase();
    return base.filter((d) =>
      [d.id, d.title, d.alt, d.description, d.story, d.collectorNotes ?? d.notes, (d.tags || d.keywords || []).join(", ")]
        .filter(Boolean)
        .some((v) => String(v).toLowerCase().includes(q))
    );
  }, [data, filter]);

  useEffect(() => {
    if (!filtered.length) return;
    const curId = filtered[idx]?.id;
    if (!curId) {
      setIdx(0);
      return;
    }
    const newPos = filtered.findIndex((d) => d.id === curId);
    if (newPos === -1) setIdx(0);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filter]);

  const current = filtered[idx] || null;

  function ensureBackup() {
    if (!backupData) return;
    const ts = new Date().toISOString().replace(/[:.]/g, "-");
    downloadText(JSON.stringify(backupData, null, 2), `BACKUP-${ts}.json`);
    downloadText(buildMjs(backupData, "galleryData"), `BACKUP-${ts}.mjs`);
    setBackupMade(true);
    setLastAction(`Backup created — ${new Date().toLocaleTimeString()}`);
  }

  function updateField(field, value) {
    if (!backupMade) return; // locked until backup
    if (!current) return;
    setData((arr) => {
      const i = arr.findIndex((d) => d.id === current.id);
      if (i === -1) return arr;
      const copy = [...arr];
      if (field === "keywords") {
        const tags = String(value)
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);
        copy[i] = { ...copy[i], tags, keywords: tags };
      } else if (field === "collectorNotes" || field === "notes") {
        // normalize in UI as collectorNotes; file may use 'notes'
        copy[i] = { ...copy[i], collectorNotes: value };
      } else {
        copy[i] = { ...copy[i], [field]: value };
      }
      return copy;
    });
    setDirty(true);
  }

  function revertCurrentToBackup() {
    if (!backupData || !current) return;
    const orig = backupData.find((d) => d.id === current.id);
    if (!orig) return;
    setData((arr) => {
      const i = arr.findIndex((d) => d.id === current.id);
      if (i === -1) return arr;
      const copy = [...arr];
      // strip ghost fields if present (UI never shows ghost anyway)
      const { id, title, alt, description, story, collectorNotes, notes, tags, keywords, url, src, section, rating, galleries, visibility, sortOrder, buyLink } = orig;
      const normalized = {
        id, title, alt, description, story,
        collectorNotes: collectorNotes ?? notes,
        tags, keywords, url, src, section, rating, galleries, visibility, sortOrder, buyLink
      };
      copy[i] = normalized;
      return copy;
    });
    setDirty(true);
    setLastAction(`Reverted CURRENT (${current.id}) — ${new Date().toLocaleTimeString()}`);
  }

  function revertAllToBackup() {
    if (!backupData) return;
    if (!confirm("Revert ALL images to the backed-up data?")) return;
    setData(backupData.filter(isRealItem).map((orig) => {
      const { id, title, alt, description, story, collectorNotes, notes, tags, keywords, url, src, section, rating, galleries, visibility, sortOrder, buyLink } = orig;
      return {
        id, title, alt, description, story,
        collectorNotes: collectorNotes ?? notes,
        tags, keywords, url, src, section, rating, galleries, visibility, sortOrder, buyLink
      };
    }));
    setDirty(true);
    setLastAction(`Reverted ALL — ${new Date().toLocaleTimeString()}`);
  }

  function move(delta) {
    const len = filtered.length;
    if (!len) return;
    let n = idx + delta;
    if (n < 0) n = 0;
    if (n > len - 1) n = len - 1;
    setIdx(n);
  }

  // Download the whole file with current UI edits (safe backup route)
  function saveAllAsMjs() {
    if (!selectedPath) return;
    const filename = selectedPath.split("/").pop() || "gallery.mjs";
    // merge UI edits back into full array (incl. ghost)
    const merged = Array.isArray(backupData) ? backupData.map((item) => {
      if (!item || !item.id) return item;
      const edited = data.find((d) => d.id === item.id);
      return edited ? edited : item;
    }) : data;
    const text = buildMjs(merged, "galleryData");
    downloadText(text, filename);
    setDirty(false);
    setLastAction(`Saved ALL → ${filename} — ${new Date().toLocaleTimeString()}`);
  }

  // In-place patch (keeps file structure, ghost, comments)
  async function saveCurrentOnly() {
    if (!selectedPath || !backupData || !current) return;

    const payload = {
      datasetPath: selectedPath.replace(/^\//, ""), // e.g. src/data/.../Black-White.mjs
      id: current.id, // read-only
      patch: {
        title: current.title ?? "",
        alt: current.alt ?? "",
        description: current.description ?? "",
        story: current.story ?? "",
        // function on server will choose 'notes' or 'collectorNotes'
        notes: current.collectorNotes ?? current.notes ?? "",
        keywords: Array.isArray(current.tags)
          ? current.tags
          : Array.isArray(current.keywords)
          ? current.keywords
          : String(current.tags || current.keywords || "")
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean),
      },
    };

    try {
      const res = await fetch("/.netlify/functions/updateGalleryItem", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error(await res.text());
      setLastAction(`Patched CURRENT (${current.id}) in-place — ${new Date().toLocaleTimeString()}`);
      setDirty(false);
    } catch (err) {
      alert("Save failed. Falling back to file download.\n\n" + err.message);
      const filename = selectedPath.split("/").pop() || "gallery.mjs";
      const edited = data.find((d) => d.id === current.id) || current;
      const merged = backupData.map((item) => (item && item.id === edited.id ? edited : item));
      const text = buildMjs(merged, "galleryData");
      downloadText(text, filename);
      setLastAction(`Saved CURRENT via download → ${filename} — ${new Date().toLocaleTimeString()}`);
    }
  }

  const total = filtered.length;
  const pos = total ? idx + 1 : 0;

  return (
    <div className="p-6 max-w-6xl mx-auto text-sm">
      <h1 className="text-2xl font-semibold mb-3">Gallery Editor Pro</h1>

      {/* dataset picker + backup gate */}
      <div className="flex flex-wrap items-center gap-2 mb-3">
        <select
          className="border rounded-md px-2 py-1 min-w-[22rem]"
          value={selectedPath}
          onChange={(e) => setSelectedPath(e.target.value)}
        >
          {options.map((o) => (
            <option key={o.path} value={o.path}>
              {o.label}
            </option>
          ))}
        </select>

        {!backupMade ? (
          <button onClick={ensureBackup} className="px-3 py-1 rounded-md border bg-white">
            1) Make Data Backup
          </button>
        ) : (
          <span className="text-green-700">✅ Backup created — editing unlocked</span>
        )}

        <div className="ml-auto flex items-center gap-2">
          <input
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
            placeholder="Search id/title/text/keywords…"
            className="w-72 border rounded-md px-2 py-1"
          />
          <button onClick={() => move(-1)} className="px-2 py-1 border rounded-md">
            Prev
          </button>
          <button onClick={() => move(1)} className="px-2 py-1 border rounded-md">
            Next
          </button>
          <span className="opacity-70">
            {pos}/{total} (of {data.length})
          </span>
        </div>
      </div>

      {/* editor + actions */}
      <div className="mb-3 flex flex-wrap items-center gap-2">
        {dirty && <span className="text-red-600 font-medium">Unsaved changes</span>}

        <button onClick={saveCurrentOnly} className="px-3 py-1 rounded-md border">
          Save This Image (.mjs)
        </button>
        <button onClick={saveAllAsMjs} className="px-3 py-1 rounded-md border">
          Save All (.mjs)
        </button>
        <button onClick={revertCurrentToBackup} className="px-3 py-1 rounded-md border">
          Revert This Image
        </button>
        <button onClick={revertAllToBackup} className="px-3 py-1 rounded-md border">
          Revert All
        </button>

        {lastAction && (
          <span className="ml-auto text-xs bg-green-50 border border-green-200 text-green-800 px-2 py-1 rounded-md">
            {lastAction}
          </span>
        )}
      </div>

      {/* editing locked notice */}
      {!backupMade && (
        <div className="mb-3 p-3 border rounded-md bg-yellow-50">
          Editing is locked until you click <strong>“Make Data Backup”</strong>. This downloads JSON + .mjs
          snapshots and enables editing. Safety first.
        </div>
      )}

      {/* main form */}
      {current ? (
        <div className={`grid grid-cols-1 md:grid-cols-2 gap-4 ${!backupMade ? "pointer-events-none opacity-60" : ""}`}>
          {/* Left: image + short fields */}
          <div className="space-y-3">
            <div className="mb-1 text-xs uppercase tracking-wide opacity-70">
              Chapter {idx + 1} of {data.length}
            </div>
            {(() => {
              const imgUrl = pickImage(current);
              return imgUrl ? (
                <img src={imgUrl} alt="" className="w-full rounded-lg shadow" />
              ) : (
                <div className="w-full h-64 grid place-items-center border rounded-lg">No image url</div>
              );
            })()}

            <div>
              <label className="block text-xs opacity-70 mb-1">ID (read-only)</label>
              <input
                value={current.id || ""}
                readOnly
                className="w-full border rounded-md px-2 py-1 bg-gray-50 text-gray-700 cursor-not-allowed"
              />
            </div>

            <div>
              <label className="block text-xs opacity-70 mb-1">Title</label>
              <input
                value={current.title || ""}
                onChange={(e) => updateField("title", e.target.value)}
                className="w-full border rounded-md px-2 py-1"
              />
            </div>

            <div>
              <label className="block text-xs opacity-70 mb-1">Alt Text</label>
              <input
                value={current.alt || ""}
                onChange={(e) => updateField("alt", e.target.value)}
                className="w-full border rounded-md px-2 py-1"
              />
            </div>

            <div>
              <label className="block text-xs opacity-70 mb-1">Keywords (comma separated)</label>
              <textarea
                value={
                  Array.isArray(current.tags)
                    ? current.tags.join(", ")
                    : Array.isArray(current.keywords)
                    ? current.keywords.join(", ")
                    : ""
                }
                onChange={(e) => updateField("keywords", e.target.value)}
                className="w-full min-h-[88px] border rounded-md px-2 py-1 resize-y"
              />
            </div>
          </div>

          {/* Right: long text fields — Story first */}
          <div className="space-y-3">
            <div>
              <label className="block text-xs opacity-70 mb-1">The Story — For people’s imagination</label>
              <textarea
                value={current.story || ""}
                onChange={(e) => updateField("story", e.target.value)}
                className="w-full h-32 border rounded-md px-2 py-1"
              />
            </div>

            <div>
              <label className="block text-xs opacity-70 mb-1">Description — Google/SEO Optimized Copy</label>
              <textarea
                value={current.description || ""}
                onChange={(e) => updateField("description", e.target.value)}
                className="w-full h-32 border rounded-md px-2 py-1"
              />
            </div>

            <div>
              <label className="block text-xs opacity-70 mb-1">
                Collector Notes — Artistic critique for collector confidence
              </label>
              <textarea
                value={current.collectorNotes ?? current.notes ?? ""}
                onChange={(e) => updateField("collectorNotes", e.target.value)}
                className="w-full h-28 border rounded-md px-2 py-1"
              />
            </div>
          </div>
        </div>
      ) : (
        <div className="p-10 text-center opacity-70">No items match your filter.</div>
      )}
    </div>
  );
}
